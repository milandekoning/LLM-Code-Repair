{
  "Cli-3": {
    "id": "Cli-3",
    "project": "Cli",
    "number": "3",
    "buggy_function": "public static Number createNumber(String str)\n    {\n        try\n        {\n            return NumberUtils.createNumber(str);\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }",
    "fixed_function": "public static Number createNumber(String str)\n    {\n        try\n        {\n            if( str != null )\n            {\n                if( str.indexOf('.') != -1 )\n                {\n                    return Double.valueOf(str);\n                }\n                else\n                {\n                    return Long.valueOf(str);\n                }\n            }\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }",
    "replacement_info": {
      "file": "src/java/org/apache/commons/cli/TypeHandler.java",
      "first_line": 157,
      "last_line": 169
    },
    "javadoc": "/**\n* <p>Create a number from a String. If a . is present, it creates a\n*    Double, otherwise a Long. </p>\n*\n* @param str the value\n* @return the number represented by <code>str</code>, if <code>str</code>\n* is not a number, null is returned.\n*/",
    "failing_tests": {
      "org.apache.commons.cli.PatternOptionBuilderTest::testSimplePattern": {
        "source": "   public void testSimplePattern()\n\n   {\n\n       try {\n\n           Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/\");\n\n           String[] args = new String[] { \"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"http://jakarta.apache.org/\" };\n\n      \n\n           CommandLineParser parser = new PosixParser();\n\n           CommandLine line = parser.parse(options,args);\n\n\n\n           // tests the char methods of CommandLine that delegate to\n\n           // the String methods\n\n           assertEquals(\"flag a\", \"foo\", line.getOptionValue(\"a\"));\n\n           assertEquals(\"flag a\", \"foo\", line.getOptionValue('a'));\n\n           assertEquals(\"string flag a\", \"foo\", line.getOptionObject(\"a\"));\n\n           assertEquals(\"string flag a\", \"foo\", line.getOptionObject('a'));\n\n           assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject(\"b\"));\n\n           assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject('b'));\n\n           assertEquals(\"boolean true flag c\", true, line.hasOption(\"c\"));\n\n           assertEquals(\"boolean true flag c\", true, line.hasOption('c'));\n\n           assertEquals(\"boolean false flag d\", false, line.hasOption(\"d\"));\n\n           assertEquals(\"boolean false flag d\", false, line.hasOption('d'));\n\n           assertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject(\"e\"));\n\n           assertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject('e'));\n\n           assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject(\"f\"));\n\n           assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject('f'));\n\n           assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\"));\n\n           assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject('n'));\n\n           assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject(\"t\"));\n\n           assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject('t'));\n\n           /// DATES NOT SUPPORTED YET.\n\n           //      assertEquals(\"number flag t\", new java.util.Date(1023400137276L), line.getOptionObject('z'));\n\n           //     input is:  \"Thu Jun 06 17:48:57 EDT 2002\"\n\n       }\n\n       catch( ParseException exp ) {\n\n           fail( exp.getMessage() );\n\n       }\n\n       catch( java.net.MalformedURLException exp ) {\n\n           fail( exp.getMessage() );\n\n       }\n\n   }\n",
        "stack_trace_summary": "junit.framework.AssertionFailedError: number flag n expected:<4.5> but was:<4.5>\n\tat org.apache.commons.cli.PatternOptionBuilderTest.testSimplePattern(PatternOptionBuilderTest.java:70)  assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\"));"
      }
    }
  },
  "JacksonDatabind-63": {
    "id": "JacksonDatabind-63",
    "project": "JacksonDatabind",
    "number": "63",
    "buggy_function": "public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { // can this ever occur?\n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    // Hmmh. Although Class.getName() is mostly ok, it does look\n                    // butt-ugly for arrays.\n                    // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n                    //   as it drops enclosing class. So let's try bit different approach\n                    String pkgName = ClassUtil.getPackageName(cls);\n                    if (pkgName != null) {\n                        sb.append(pkgName);\n                        sb.append('.');\n                    }\n                    sb.append(cls.getSimpleName());\n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }",
    "fixed_function": "public String getDescription() {\n            if (_desc == null) {\n                StringBuilder sb = new StringBuilder();\n\n                if (_from == null) { // can this ever occur?\n                    sb.append(\"UNKNOWN\");\n                } else {\n                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n                    // Hmmh. Although Class.getName() is mostly ok, it does look\n                    // butt-ugly for arrays.\n                    // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n                    //   as it drops enclosing class. So let's try bit different approach\n                    int arrays = 0;\n                    while (cls.isArray()) {\n                        cls = cls.getComponentType();\n                        ++arrays;\n                    }\n                    sb.append(cls.getName());\n                    while (--arrays >= 0) {\n                        sb.append(\"[]\");\n                    }\n                    /* was:\n                    String pkgName = ClassUtil.getPackageName(cls);\n                    if (pkgName != null) {\n                        sb.append(pkgName);\n                        sb.append('.');\n                    }\n                    */\n                }\n                sb.append('[');\n                if (_fieldName != null) {\n                    sb.append('\"');\n                    sb.append(_fieldName);\n                    sb.append('\"');\n                } else if (_index >= 0) {\n                    sb.append(_index);\n                } else {\n                    sb.append('?');\n                }\n                sb.append(']');\n                _desc = sb.toString();\n            }\n            return _desc;\n        }",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java",
      "first_line": 118,
      "last_line": 151
    },
    "javadoc": "/**\n* Object through which reference was resolved. Can be either\n* actual instance (usually the case for serialization), or\n* Class (usually the case for deserialization).\n*<p>\n* Note that this value must be `transient` to allow serializability (as\n* often such Object is NOT serializable; or, in case of `Class`, may\n* not available at the point of deserialization). As such will return\n* `null` if instance has been passed using JDK serialization.\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.exc.ExceptionPathTest::testReferenceChainForInnerClass": {
        "source": "    public void testReferenceChainForInnerClass() throws Exception\n\n    {\n\n        String json = MAPPER.writeValueAsString(new Outer());\n\n        try {\n\n            MAPPER.readValue(json, Outer.class);\n\n            fail(\"Should not pass\");\n\n        } catch (JsonMappingException e) {\n\n            JsonMappingException.Reference reference = e.getPath().get(0);\n\n            assertEquals(getClass().getName()+\"$Outer[\\\"inner\\\"]\",\n\n                    reference.toString());\n\n        }\n\n    }\n",
        "stack_trace_summary": "junit.framework.ComparisonFailure: expected:<....databind.deser.exc.[ExceptionPathTest$]Outer[\"inner\"]> but was:<....databind.deser.exc.[]Outer[\"inner\"]>\n\tat com.fasterxml.jackson.databind.deser.exc.ExceptionPathTest.testReferenceChainForInnerClass(ExceptionPathTest.java:37)  assertEquals(getClass().getName()+\"$Outer[\\\"inner\\\"]\","
      },
      "com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithDefaultDeserialization::testShouldThrowJsonMappingExceptionWithPathReference": {
        "source": "    public void testShouldThrowJsonMappingExceptionWithPathReference() throws IOException {\n\n        // given\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        String input = \"{\\\"bar\\\":{\\\"baz\\\":{qux:\\\"quxValue\\\"))}\";\n\n        final String THIS = getClass().getName();\n\n\n\n        // when\n\n        try {\n\n            mapper.readValue(input, Foo.class);\n\n            fail(\"Upsss! Exception has not been thrown.\");\n\n        } catch (JsonMappingException ex) {\n\n            // then\n\n            assertEquals(THIS+\"$Foo[\\\"bar\\\"]->\"+THIS+\"$Bar[\\\"baz\\\"]\",\n\n                    ex.getPathReference());\n\n        }\n\n    }\n\n}\n",
        "stack_trace_summary": "junit.framework.ComparisonFailure: expected:<....databind.deser.exc.[TestExceptionHandlingWithDefaultDeserialization$Foo[\"bar\"]->com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithDefaultDeserialization$]Bar[\"baz\"]> but was:<....databind.deser.exc.[Foo[\"bar\"]->com.fasterxml.jackson.databind.deser.exc.]Bar[\"baz\"]>\n\tat com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithDefaultDeserialization.testShouldThrowJsonMappingExceptionWithPathReference(TestExceptionHandlingWithDefaultDeserialization.java:53)  assertEquals(THIS+\"$Foo[\\\"bar\\\"]->\"+THIS+\"$Bar[\\\"baz\\\"]\","
      },
      "com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithJsonCreatorDeserialization::testShouldThrowJsonMappingExceptionWithPathReference": {
        "source": "    public void testShouldThrowJsonMappingExceptionWithPathReference() throws IOException {\n\n        // given\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        String input = \"{\\\"bar\\\":{\\\"baz\\\":{qux:\\\"quxValue\\\"))}\";\n\n        final String THIS = getClass().getName();\n\n\n\n        // when\n\n        try {\n\n            mapper.readValue(input, Foo.class);\n\n            fail(\"Upsss! Exception has not been thrown.\");\n\n        } catch (JsonMappingException ex) {\n\n            // then\n\n            assertEquals(THIS+\"$Foo[\\\"bar\\\"]->\"+THIS+\"$Bar[\\\"baz\\\"]\",\n\n                    ex.getPathReference());\n\n        }\n\n    }\n\n}\n",
        "stack_trace_summary": "junit.framework.ComparisonFailure: expected:<....databind.deser.exc.[TestExceptionHandlingWithJsonCreatorDeserialization$Foo[\"bar\"]->com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithJsonCreatorDeserialization$]Bar[\"baz\"]> but was:<....databind.deser.exc.[Foo[\"bar\"]->com.fasterxml.jackson.databind.deser.exc.]Bar[\"baz\"]>\n\tat com.fasterxml.jackson.databind.deser.exc.TestExceptionHandlingWithJsonCreatorDeserialization.testShouldThrowJsonMappingExceptionWithPathReference(TestExceptionHandlingWithJsonCreatorDeserialization.java:64)  assertEquals(THIS+\"$Foo[\\\"bar\\\"]->\"+THIS+\"$Bar[\\\"baz\\\"]\","
      }
    }
  },
  "JacksonDatabind-64": {
    "id": "JacksonDatabind-64",
    "project": "JacksonDatabind",
    "number": "64",
    "buggy_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType;\n    try {\n        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n\n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n            _defaultInclusion);\n\n    // property annotation override\n    \n    inclV = inclV.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to access values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class/type specifying it; try to find POJO property defaults\n\n        // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n        //    revert logic to the case of general/per-property handling, so both\n        //    type-default AND null are to be excluded.\n        //    (as per [databind#1417]\n        if (_useRealPropertyDefaults) {\n            // 07-Sep-2016, tatu: may also need to front-load access forcing now\n            if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n            suppressNulls = true;\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "fixed_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType;\n    try {\n        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n\n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n            _defaultInclusion);\n\n    // property annotation override\n    \n    inclV = inclV.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to access values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class/type specifying it; try to find POJO property defaults\n        Object defaultBean;\n\n        // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n        //    revert logic to the case of general/per-property handling, so both\n        //    type-default AND null are to be excluded.\n        //    (as per [databind#1417]\n        if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n            // 07-Sep-2016, tatu: may also need to front-load access forcing now\n            if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            try {\n                valueToSuppress = am.getValue(defaultBean);\n            } catch (Exception e) {\n                _throwWrapped(e, propDef.getName(), defaultBean);\n            }\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n            suppressNulls = true;\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
      "first_line": 90,
      "last_line": 216
    },
    "javadoc": "/**\n* @param contentTypeSer Optional explicit type information serializer\n*    to use for contained values (only used for properties that are\n*    of container type)\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.filter.JsonIncludeTest::testIssue1351": {
        "source": "    public void testIssue1351() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);\n\n        assertEquals(aposToQuotes(\"{}\"),\n\n                mapper.writeValueAsString(new Issue1351Bean(null, (double) 0)));\n\n        // [databind#1417]\n\n        assertEquals(aposToQuotes(\"{}\"),\n\n                mapper.writeValueAsString(new Issue1351NonBean(0)));\n\n    }\n",
        "stack_trace_summary": "junit.framework.ComparisonFailure: expected:<{[]}> but was:<{[\"str\":null]}>\n\tat com.fasterxml.jackson.databind.filter.JsonIncludeTest.testIssue1351(JsonIncludeTest.java:320)  assertEquals(aposToQuotes(\"{}\"),"
      }
    }
  },
  "JacksonDatabind-54": {
    "id": "JacksonDatabind-54",
    "project": "JacksonDatabind",
    "number": "54",
    "buggy_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              //serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "fixed_function": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n              //serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "replacement_info": {
      "file": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
      "first_line": 68,
      "last_line": 171
    },
    "javadoc": "/**\n* @param contentTypeSer Optional explicit type information serializer\n*    to use for contained values (only used for properties that are\n*    of container type)\n*/",
    "failing_tests": {
      "com.fasterxml.jackson.databind.deser.TestJDKAtomicTypes::testEmpty1256": {
        "source": "    public void testEmpty1256() throws Exception\n\n    {\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);\n\n\n\n        String json = mapper.writeValueAsString(new Issue1256Bean());\n\n        assertEquals(\"{}\", json);\n\n    }\n",
        "stack_trace_summary": "junit.framework.ComparisonFailure: expected:<{[]}> but was:<{[\"a\":null]}>\n\tat com.fasterxml.jackson.databind.deser.TestJDKAtomicTypes.testEmpty1256(TestJDKAtomicTypes.java:268)  assertEquals(\"{}\", json);"
      }
    }
  },
  "Gson-5": {
    "id": "Gson-5",
    "project": "Gson",
    "number": "5",
    "buggy_function": "public static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) { // number of digits parsed\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String timezoneId = \"GMT\" + timezoneOffset;\n                  //String timezoneId = \"UTC\" + timezoneOffset;\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                +timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\"+fail.getClass().getName()+\")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}",
    "fixed_function": "public static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        \n        if (!hasT && (date.length() <= offset)) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n\n            // extract hours, minutes, seconds and milliseconds\n            hour = parseInt(date, offset += 1, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n            // second and milliseconds can be optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1;\n                        int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n                        int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        // compensate for \"missing\" digits\n                        switch (parseEndOffset - offset) { // number of digits parsed\n                        case 2:\n                            milliseconds = fraction * 10;\n                            break;\n                        case 1:\n                            milliseconds = fraction * 100;\n                            break;\n                        default:\n                            milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset += 1;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneOffset = date.substring(offset);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n            timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n\n            offset += timezoneOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                timezone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                //String timezoneId = \"GMT\" + timezoneOffset;\n                  String timezoneId = \"UTC\" + timezoneOffset;\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n\n                String act = timezone.getID();\n                if (!act.equals(timezoneId)) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String cleaned = act.replace(\":\", \"\");\n                    if (!cleaned.equals(timezoneId)) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n                                +timezone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\"+fail.getClass().getName()+\")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}",
    "replacement_info": {
      "file": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java",
      "first_line": 123,
      "last_line": 276
    },
    "javadoc": "/**\n* Parse a date from ISO-8601 formatted string. It expects a format\n* [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n*\n* @param date ISO string to parse in the appropriate format.\n* @param pos The position to start parsing from, updated to where parsing stopped.\n* @return the parsed date\n* @throws ParseException if the date is not in the appropriate format\n*/",
    "failing_tests": {
      "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601": {
        "source": "  public void testDateDeserializationISO8601() throws Exception {\n\n  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n\n    assertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\n\n    assertParsed(\"1970-01-01T00:00Z\", adapter);\n\n    assertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\n\n    assertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\n\n    assertParsed(\"1970-01-01T01:00:00+01\", adapter);\n\n  }\n",
        "stack_trace_summary": "com.google.gson.JsonSyntaxException: 1970-01-01T01:00:00+01\n\tat com.google.gson.DefaultDateTypeAdapter.deserializeToDate(DefaultDateTypeAdapter.java:107)  throw new JsonSyntaxException(json.getAsString(), e);\n\tat com.google.gson.DefaultDateTypeAdapter.deserialize(DefaultDateTypeAdapter.java:84)  Date date = deserializeToDate(json);\n\tat com.google.gson.DefaultDateTypeAdapterTest.assertParsed(DefaultDateTypeAdapterTest.java:168)  assertEquals(date, new Date(0), adapter.deserialize(new JsonPrimitive(date), Date.class, null));\n\tat com.google.gson.DefaultDateTypeAdapterTest.testDateDeserializationISO8601(DefaultDateTypeAdapterTest.java:133)  assertParsed(\"1970-01-01T01:00:00+01\", adapter);\n\tat com.google.gson.internal.bind.util.ISO8601Utils.parse(ISO8601Utils.java:273)  ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n\tat com.google.gson.DefaultDateTypeAdapter.deserializeToDate(DefaultDateTypeAdapter.java:105)  return ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n\tat com.google.gson.internal.bind.util.ISO8601Utils.parse(ISO8601Utils.java:239)  +timezone.getID());"
      }
    }
  }
}